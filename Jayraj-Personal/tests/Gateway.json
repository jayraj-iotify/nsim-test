{
  "id": "62ea52606d2a5e9329992899",
  "name": "Gateway",
  "tags": {},
  "labels": [],
  "workspaceId": "6246fbe2fdee1fd07c3bb327",
  "version": 1,
  "createdBy": "6246fbe2fdee1fd07c3bb324",
  "lastUpdateBy": "6246fbe2fdee1fd07c3bb324",
  "lastUpdatedOn": "2022-08-03T10:48:00.727Z",
  "definition": {
    "protocol": "mqtt",
    "clientId": "",
    "strategy": "Default",
    "settings": {
      "url": "mqtts://a3cs3g754w2d11.iot.us-east-1.amazonaws.com:8883",
      "topic": "$aws/things/{{state.pubTopic}}",
      "subscriptionTopics": [
        "$aws/things/{{state._$gateway.thingName}}/#"
      ],
      "timeout": 60000,
      "qos": 0,
      "retain": false,
      "keepalive": 60000,
      "reconnectPeriod": 60000,
      "connectTimeout": 120000,
      "username": "",
      "password": "",
      "identity": "",
      "psk": "",
      "key": "{{state._$key}}",
      "cert": "{{state._$cert}}",
      "ca": "-----BEGIN CERTIFICATE-----\nMIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCB\nyjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\nExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJp\nU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxW\nZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0\naG9yaXR5IC0gRzUwHhcNMDYxMTA4MDAwMDAwWhcNMzYwNzE2MjM1OTU5WjCByjEL\nMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZW\nZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2ln\nbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\nU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9y\naXR5IC0gRzUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1\nnmAMqudLO07cfLw8RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKzj/i5Vbex\nt0uz/o9+B1fs70PbZmIVYc9gDaTY3vjgw2IIPVQT60nKWVSFJuUrjxuf6/WhkcIz\nSdhDY2pSS9KP6HBRTdGJaXvHcPaz3BJ023tdS1bTlr8Vd6Gw9KIl8q8ckmcY5fQG\nBO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9r911kTMZHRxAy3QkGSGT2RT+\nrCpSx4/VBEnkjWNHiDxpg8v+R70rfk/Fla4OndTRQ8Bnc+MUCH7lP59zuDMKz10/\nNIeWiu5T6CUVAgMBAAGjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\nBAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAH\nBgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVy\naXNpZ24uY29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFH/TZafC3ey78DAJ80M5+gKv\nMzEzMA0GCSqGSIb3DQEBBQUAA4IBAQCTJEowX2LP2BqYLz3q3JktvXf2pXkiOOzE\np6B4Eq1iDkVwZMXnl2YtmAl+X6/WzChl8gGqCBpH3vn5fJJaCGkgDdk+bW48DW7Y\n5gaRQBi5+MHt39tBquCWIMnNZBU4gcmU7qKEKQsTb47bDN0lAtukixlE0kF6BWlK\nWE9gyn6CagsCqiUXObXbf+eEZSqVir2G3l6BFoMtEMze/aiCKm0oHw0LxOXnGiYZ\n4fQRbxC1lfznQgUy286dUV4otp6F01vvpX1FQHKOtw5rDgb7MzVIcbidJ4vEZV8N\nhnacRHr2lVz2XTIIM6RUthg/aFzyQkqFOFSDX9HoLPKsEdao7WNq\n-----END CERTIFICATE-----"
    },
    "model": {
      "currentState": "Init",
      "stateMap": {
        "Helpers": {
          "index": 1,
          "name": "Helpers",
          "isEnabled": true,
          "sender": "{\n  let hubFunctions = {};\n  const fwVer = [\"2.4.6.8\", \"2.5.8.9\", \"2.7.2.0\"]; // TODO: change these to const\n  const curr_conn_type = [\"wifi\", \"cellular\", \"ethernet\"];\n  const board_type = [\"V2\", \"V3\", \"V4\"];\n  const model = [\"sim7500a\", \"sim5300a\"];\n  const time_zone = [\n    \"Asia/Kolkata\",\n    \"Asia/Japan\",\n    \"Asia/Bangladesh\",\n    \"Asia/Korea\",\n    \"Asia/China\",\n  ];\n  const lock_models = [\n    \"540-25419-20556\",\n    \"297-32780-3840\",\n    \"297-32770-4096\",\n    \"297-32770-5632\",\n    \"297-32772-1536\",\n    \"297-32771-2816\",\n    \"297-32769-2816\",\n    \"297-32770-1536\",\n    \"297-32779-3840\",\n    \"297-64155-48896\",\n    \"297-3-1033\",\n    \"297-2-0\",\n    \"297-1-1033\",\n    \"144-1-1\",\n    \"59-25409-20548\",\n    \"297-4-2048\",\n    \"297-2-2048\",\n    \"297-4-521\",\n    \"297-32827-1288\",\n    \"144-3-568\",\n    \"144-2065-5032\",\n    \"541-259-3\",\n    \"297-32826-1288\",\n  ];\n  const thermostat_models = [\n    \"351-1540-20737\",\n    \"21076-512-33136\",\n    \"16-20563-12849\",\n    \"57-17-1\",\n    \"335-21570-21559\",\n    \"335-21570-21558\",\n    \"335-21570-21553\",\n    \"400-1-1\",\n    \"275-17750-21556\",\n    \"152-25601-263\",\n    \"152-51201-36\",\n    \"155-21332-23089\",\n    \"41366-99f5f9e6-d181\",\n    \"57-17-8\",\n  ];\n  const shared = {\n    LockMACs: [\n      \"D5:0B:94:3B:D6:6B\",\n      \"DA:DF:DB:9F:62:EC\",\n      \"E2:99:7F:CB:FF:CB\",\n      \"D0:0D:F4:29:DF:48\",\n      \"DB:42:93:D9:0B:A6\",\n      \"CC:9F:CB:F9:71:2A\",\n      \"CC:FD:C5:D8:CF:8D\",\n      \"E2:48:B0:60:CD:DA\",\n      \"C5:16:4C:60:D5:21\",\n      \"FD:42:C6:0A:8D:FB\",\n    ],\n  };\n\n  hubFunctions.heartBeat = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: {\n            heartBeat: state._$timestamp.toISOString(),\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendFWver = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: state._$gateway.firmware,\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.hubPower = async function () {\n    let powerArr = [];\n\n    if (state._$gateway.power.status === \"unplugged\") {\n      powerArr.push(\"0x01\");\n      powerArr.push(state._$gateway.power.level);\n    } else {\n      powerArr.push(\"0xc1\");\n      powerArr.push(100);\n    }\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            powerNotification: powerArr,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.addThermostat = async function () {\n    // randomly pick a device type\n    // nodeId ranges from 2 to 232. Hence array length +2\n    // logic to detemine model yet to be added.\n\n    // \t\tstate.devices = state._$gateway.devices\n\n    let deviceType = \"thermostat\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(thermostat_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.addLock = async function () {\n    // randomly pick a device type\n    // nodeId ranges from 2 to 232. Hence array length +2\n    // logic to detemine model yet to be added.\n\n    // \t\tstate.devices = state._$gateway.devices\n\n    let deviceType = \"lock\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(lock_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.removeDevice = async function () {\n    let res = {};\n    if (\n      (Array.isArray(state._$gateway.devices) &&\n        state._$gateway.devices.length === 0) ||\n      state._$gateway.devices === undefined\n    ) {\n      console.log(\"ERR: No devices to delete\");\n      state.payload_err = \"No devices to delete\";\n    } else {\n      let device = chance.pickone(state._$gateway.devices);\n\n      let nodeId = \"\" + device.nodeId;\n\n      res = {\n        state: {\n          reported: {\n            thing_name: state._$gateway.thingName,\n            notification: {\n              remove_device: {\n                [nodeId]: \"delete\",\n              },\n            },\n          },\n        },\n      };\n\n      state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    }\n\n    return res;\n  };\n\n  hubFunctions.sendConnectionType = async function () {\n    if (state._$gateway.connection.curr_conn_type === \"wifi\") {\n      state._$gateway.connection.wifi_ssid =\n        \"WIFI-\" +\n        chance.integer({\n          min: 1,\n          max: 50,\n        });\n      state._$gateway.connection.wifi_ss = chance.integer({\n        min: 0,\n        max: 100,\n      });\n    } else if (state._$gateway.connection.curr_conn_type === \"cellular\") {\n      state._$gateway.connection.csq =\n        \"\" +\n        chance.floating({\n          min: 1.99,\n          max: 32.99,\n          fixed: 2,\n        });\n    }\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: state._$gateway.connection,\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendBoardType = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: state._$gateway.board,\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendICCID = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: state._$gateway.sim,\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.factoryTest = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          settings: state._$gateway.factory,\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendBLEmode = async function () {\n\n    let p = await state.hubFunctions.sendBLEcmd();\n    protocol.publish(JSON.stringify(p));\n\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            mode: state._$gateway.ble.mode,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    \n    return response;\n  };\n\n  hubFunctions.sendBLEcmd = async function () {\n    //if BLE mode is 'central', readyForBleCmds is true\n    //if BLE mode is 'peripheral', readyForBleCmds is false\n    state._$gateway.ble.readyForBleCmds = {\n      central: \"true\",\n      peripheral: \"false\",\n    }[state._$gateway.ble.mode];\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            readyForBleCmds: state._$gateway.ble.readyForBleCmds,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.rebootHub = async function () {\n    state.BootIterationsLeft = state._$REBOOT_SLEEP;\n    console.log(\"Starting Reboot\");\n\n    // state._$gateway.ble.mode = \"peripheral\";\n\n    await state.hubFunctions.switchPeripheral()\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    next(\"Booting\");\n    return {};\n  };\n\n  hubFunctions.upgradeReport = async function () {\n    // Change to stateless - client token should be function param\n    // state.upgrade = {\n    //     clientToken: \"blah\"\n    // }\n    // TODO: model increments of version also\n    let res = {\n      cmd: \"report\",\n      data: {\n        version: \"2.09\",\n        networker: \"2.90\",\n        iotCount: 1,\n        tree: {\n          hub: \"8ebd67b673eb42a3e23865049cda3df9\",\n          modules: \"a5bc72da682103f1d58b8c3321f1a1e9\",\n        },\n        mountWanted: true,\n        mountActive: true,\n        hubWanted: true,\n        hubActive: false,\n        treeMode: \"idle\",\n        md5TreeBusy: false,\n      },\n      clientToken: state.upgrade.clientToken,\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/admin\";\n    return res;\n  };\n\n  hubFunctions.wifiScan = async function () {\n    // Change to stateless - client token should be function param\n    // state.scan = {\n    //     clientToken: \"blah\"\n    // }\n\n    let res = {\n      cmd: \"scan\",\n      clientToken: state.scan.clientToken,\n      data: {\n        wifi_ssids: [\"Test\", \"test1\"],\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/admin\";\n    return res;\n  };\n\n  hubFunctions.BLEscan = async function () {\n    let res = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            scanDeviceReport: [\n              chance.pickone(shared.LockMACs),\n              chance.integer({\n                min: -100,\n                max: 0,\n              }),\n              chance.integer({\n                min: 0,\n                max: 1,\n              }),\n              chance.integer({\n                min: 0,\n                max: 1,\n              }),\n              chance.integer({\n                min: 0,\n                max: 100,\n              }),\n            ],\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    // let z = await state.hubFunctions.BLEfirmware();\n    // protocol.publish(z)\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return res;\n  };\n\n  hubFunctions.BLEfirmware = async function () {\n    // 1.10 .. 1.21\n    let res = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            lockFWVer: [\n              chance.pickone(shared.LockMACs),\n              chance.floating({\n                min: 1.1,\n                max: 1.21,\n                fixed: 2,\n              }),\n            ],\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return res;\n  };\n\n  hubFunctions.switchPeripheral = async function () {\n    state._$gateway.ble.mode = \"peripheral\";\n\n    let p = await state.hubFunctions.sendBLEmode();\n    protocol.publish(JSON.stringify(p));\n    // state.PAYLOADS.push(p);\n    return {};\n  };\n  hubFunctions.switchCentral = async function () {\n    state._$gateway.ble.mode = \"central\";\n\n    let p = await state.hubFunctions.sendBLEmode();\n    protocol.publish(JSON.stringify(p));\n    // state.PAYLOADS.push(p);\n    return {};\n  };\n\n  hubFunctions.triggerOffline = async function () {\n    state._$nextExecution.triggerClearingUnsent = Date.now() + 180000;\n\n    console.log(\"SEQINFO: Triggering next state to offline\")\n    next('Offline')\n  }\n\n  hubFunctions.triggerClearingUnsent = async function () {\n    console.log(\"SEQINFO: Triggering next state to clearing_unsent\")\n    next('Clearing_Unsent')\n  }\n\n  hubFunctions.getGateway = async function () {\n    let topic = \"$aws/things/\" + state._$gateway.thingName + \"/shadow/get\";\n    let payload = {};\n    console.log(\"Sending\", payload, \" to \", topic);\n    state.getGatewayTimerStart = Date.now();\n    protocol.publish(payload, topic);\n  };\n\n  state.hubFunctions = hubFunctions;\n\n  state._$nextExecution = {};\n  state._$iterationConfig.forEach(function (obj) {\n    state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n  });\n\n  state._$helpers = {};\n\n  state._$helpers.initGateway = async function () {\n    state._$gateway.power = {\n      status: \"plugged\",\n      level: chance.integer({ min: 0, max: 100 }),\n    };\n    state._$gateway.devices = [];\n    state._$gateway.deviceGUIDs = [];\n    state._$gateway.locks = 0;\n    state._$gateway.thermostats = 0;\n    state._$gateway.nextNodeId = 2;\n    state._$gateway.firmware = { fwVer: chance.pickone(fwVer) };\n    state._$gateway.connection = {\n      curr_conn_type: chance.pickone(curr_conn_type),\n    };\n    state._$gateway.board = {\n      board_type: chance.pickone(board_type),\n      model: chance.pickone(model),\n    };\n    state._$gateway.sim = {\n      imei: chance.string({ length: 15, numeric: true }),\n      iccid: chance.string({ length: 19, numeric: true }),\n    };\n    state._$gateway.factory = {\n      rently_batch_code_duration: chance.integer({ min: 1, max: 4 }) * 30,\n      time_zone: chance.pickone(time_zone),\n      agingTest: chance.pickone(['enable', 'disable']),\n    };\n    state._$gateway.rebooting = { status: false };\n    state._$gateway.ble = { mode: \"central\" };\n\n    glob.set(\"gateway_\" + client(), state._$gateway);\n    console.log(\"SEQINFO: Completed Initializing Gateway.\");\n\n    return true;\n  };\n\n  state._$helpers.handleDelta = async function (res) {\n    let resub = false;\n    console.log(\"SEQINFO: Processing Delta\");\n    metric.add('Gateway_deltaProcessed')\n    if (!!res.state) {\n      let deltaDevices = res?.state?.settings?.devices;\n\n      if (Array.isArray(deltaDevices) && deltaDevices.length > 0) {\n        console.log(\"Devices are Present in delta\");\n        console.log(\"res : \", res);\n        let count = 0\n        deltaDevices.forEach(async (device_thing_name) => {\n          if (!state._$gateway.deviceGUIDs.includes(device_thing_name)) {\n            console.log(\"Found New Device : \", device_thing_name);\n            if (!state.unverifiedDeviceGUIDs.includes(device_thing_name)) {\n              state.unverifiedDeviceGUIDs.push(device_thing_name);\n              resub = true;\n              state.subscriptionTopics.push(\n                \"$aws/things/\" + device_thing_name + \"/#\"\n              );\n              ++count;\n              metric.add(\n                \"Gateway_newDeltaDeviceTime\",\n                Date.now() - state.addDeviceTimerStart\n              );\n            } else {\n              console.log(\"Device already present in unverifiedDeviceGUIDs\");\n            }\n          } else {\n            console.log(\"Device already present in DeviceGUIDs\");\n          }\n        });\n        if (resub) {\n          protocol.resubscribe(state.subscriptionTopics);\n          metric.add(\"Gateway_resubscribe\");\n          console.log(\"Subscription Topics: \", state.subscriptionTopics);\n\n          glob.incr(\"Gateway_newDeltaDevice\", count);\n          metric.add(\"Gateway_newDeltaDevice\", count);\n        }\n        if (state._$gateway.deviceGUIDs.length > deltaDevices.length) {\n          state._$helpers.checkDevices(deltaDevices)\n        }\n      } else {\n        console.log(\"No devices present in Delta\");\n        metric.add('Gateway_deltaReceivedWithoutDevices')\n\n        try {\n          protocol.publish(JSON.stringify(await state.hubFunctions.heartBeat()));\n        } catch (e) {\n          console.log(\"ERR: Error sending Heartbeat\", e);\n        }\n      }\n      state.DELTA = res.state;\n      // if (state.MAX_VERBOSE) state.PREV_DELTAS.push(res);\n      let echo = {\n        state: {\n          reported: {\n            ...state.DELTA,\n            thing_name: state._$gateway.thingName,\n            updateTime: state._$timestamp.toISOString(),\n          },\n        },\n      };\n      // if (!!echo.state.reported?.settings?.devices) delete echo.state.reported.settings.devices\n      protocol.publish(JSON.stringify(echo));\n      if (state.MAX_VERBOSE)\n        console.log(\"Echo Accepted : \", JSON.stringify(res));\n      return true;\n    } else {\n      console.log(\"No state found in received delta\");\n      metric.add('Gateway_deltaReceivedWithoutState')\n\n      return false;\n    }\n  };\n\n  state._$helpers.checkDevices = async function (desiredDevices) {\n    console.log(\"Checking Devices\");\n    metric.add(\"Gateway_checkDevices\");\n\n    if (desiredDevices && Array.isArray(desiredDevices)) {\n      if (desiredDevices.length === 0) {\n        metric.add(\"Gateway_CheckingEmptyDeviceArray\");\n        console.log(\"Empty Devices Array\", desiredDevices);\n        return null;\n      }\n      console.log(\"INFO: Received devices : \", desiredDevices);\n      state.newDevices = _.difference(\n        desiredDevices,\n        state._$gateway.deviceGUIDs\n      );\n      state.removeDevices = _.difference(\n        state._$gateway.deviceGUIDs,\n        desiredDevices\n      );\n      console.log(\"New Devices Received: \", state.newDevices);\n      console.log(\"Missing Devices to be Removed: \", state.removeDevices);\n      if (state.newDevices.length > 0 || state.removeDevices.length > 0) {\n        state.subscriptionTopics = [];\n        state.subscriptionTopics.push(\n          \"$aws/things/\" + state._$gateway.thingName + \"/#\"\n        );\n\n        state.newDevices.forEach(async (deviceGUID) => {\n          state.subscriptionTopics.push(\"$aws/things/\" + deviceGUID + \"/#\");\n          if (!state.unverifiedDeviceGUIDs.includes(deviceGUID)) {\n            state.unverifiedDeviceGUIDs.push(deviceGUID);\n            metric.add(\"Gateway_CheckFoundNewDevice\");\n            console.log(\"INFO: Pushing device to unverifiedDeviceGUIDs\");\n            console.log(\n              \"unverifiedDeviceGUIDs.length=\",\n              state.unverifiedDeviceGUIDs.length\n            );\n          } else {\n            console.log(\n              \"INFO: unverifiedDeviceGUIDs already contains \" + deviceGUID\n            );\n          }\n        });\n        state.removeDevices.forEach((deviceGUID) => {\n\n          console.log(\"Removing device: \", deviceGUID, \" from gateway: \");\n          let gatewayLocks = (await glob.get(\"G\" + client() + \"_ActiveLocks\")) || {};\n\n          let gatewayThermostats = (await glob.get(\"G\" + client() + \"_ActiveThermostats\")) || {};\n\n          if (!!gatewayLocks[deviceGUID]) {\n            delete gatewayLocks[deviceGUID];\n            glob.set(\"G\" + client() + \"_ActiveLocks\", gatewayLocks)\n          }\n\n          if (!!gatewayThermostats[deviceGUID]) {\n            delete gatewayThermostats[deviceGUID];\n            glob.set(\"G\" + client() + \"_ActiveThermostats\", gatewayThermostats)\n          }\n\n          state._$gateway.devices = state._$gateway.devices.filter(\n            (device) => device.thing_name !== deviceGUID\n          );\n          state._$gateway.deviceGUIDs = state._$gateway.deviceGUIDs.filter(\n            (dev) => dev !== deviceGUID\n          );\n        });\n        state.newDevices = [];\n        state.removeDevices = [];\n        console.log(\"Subscription Topics: \", state.subscriptionTopics);\n        try {\n          protocol.resubscribe(state.subscriptionTopics);\n          metric.add(\"Gateway_resubscribe\");\n        } catch (e) {\n          console.log(\"ERR: Re-Subscribe Failed : \", e);\n        }\n      }\n    } else {\n      console.log(\"ERR: devices passed is not an array \", desiredDevices);\n    }\n  };\n\n  state._$helpers.checkDevicesParity = async function () {\n    metric.add(\"Gateway_checkDevicesParity\");\n    console.log(\"SEQINFO: Checking parity of devices Array\");\n    if (state._$gateway.nextNodeId > 2) {\n      let activeDeviceCount = state._$gateway.deviceGUIDs.length || 0;\n      console.log(\n        \"INFO: Active Device Count for this Gateway : \",\n        activeDeviceCount\n      );\n      if (state._$gateway.nextNodeId - 2 !== activeDeviceCount) {\n        console.log(\"INFO: Triggering get request for Gateway\");\n        await state.hubFunctions.getGateway();\n        metric.add(\"Gateway_getGateway\");\n      } else {\n        console.log(\"Active device count is same as requests sent.\");\n      }\n    } else {\n      console.log(\"INFO: No device requests were sent by this gateway\");\n    }\n  };\n\n  state._$helpers.newDevice = async function (res) {\n    if (\n      res?.state?.desired?.thing_name &&\n      !state._$gateway.deviceGUIDs.includes(res?.state?.desired?.thing_name)\n    ) {\n      metric.add(\"Gateway_NewDeviceResponse\");\n      state.NEWDEVICERES = res;\n      let newDevice = {\n        thing_name: res?.state?.desired?.thing_name,\n        nodeId: res?.state?.desired?.settings?.node_no,\n        deviceType: res?.state?.desired?.settings?.type,\n      };\n\n      console.log(\"New device created is : \", newDevice);\n\n      if (newDevice.deviceType === \"lock\") {\n        state._$gateway.locks++;\n        // newDevice.globKey = \"L\" + state._$gateway.locks + \"G\" + client();\n        // await glob.set(newDevice.globKey, newDevice);\n        // await mailbox.post('G' + index() + '_Locks', newDevice)\n        let gatewayLocks =\n          (await glob.get(\"G\" + client() + \"_ActiveLocks\")) || {};\n        gatewayLocks[newDevice.thing_name] = newDevice;\n        await glob.set(\"G\" + client() + \"_ActiveLocks\", gatewayLocks);\n        console.log(\"Stored Lock to G\" + client() + \"_ActiveLocks\");\n        metric.add(\"Gateway_lockCreationComplete\");\n      } else if (newDevice.deviceType === \"thermostat\") {\n        state._$gateway.thermostats++;\n        let gatewayThermostats =\n          (await glob.get(\"G\" + client() + \"_ActiveThermostats\")) || {};\n        gatewayThermostats[newDevice.thing_name] = newDevice;\n        await glob.set(\n          \"G\" + client() + \"_ActiveThermostats\",\n          gatewayThermostats\n        );\n        console.log(\"Stored Thermostat to G\" + client() + \"_ActiveThermostats\");\n        metric.add(\"Gateway_thermostatCreationComplete\");\n      }\n\n      console.log(\n        \"Removing \" + newDevice.thing_name + \" from unverified devices\"\n      );\n      state.unverifiedDeviceGUIDs = state.unverifiedDeviceGUIDs.filter(\n        (deviceGUID) => deviceGUID !== newDevice.thing_name\n      );\n\n      console.log(\"New Device : \", newDevice);\n      console.log(\"Pending unverified devices : \", state.unverifiedDeviceGUIDs);\n\n      state._$gateway.devices.push(newDevice);\n      state._$gateway.deviceGUIDs.push(res?.state?.desired?.thing_name);\n    } else {\n      console.log(\"INFO: Duplicate handler\");\n    }\n\n    glob.set(\"gateway_\" + client(), state._$gateway);\n    return true;\n  };\n\n  state._$helpers.checkManualTrigger = async function () {\n    let manualTrigger = await glob.get(\"manualTrigger\");\n\n    if (manualTrigger.count > state.gatewayManualTriggerCount) {\n      console.log(\"INFO: Received Manual Trigger for \" + manualTrigger.fun);\n\n      let check = state._$iterationConfig.find(\n        (o) => o.fun === manualTrigger.fun\n      );\n\n      if (!check) {\n        console.log(\n          \"ERR: Invalid Manual Trigger. Function doesn't exist in iterationConfig.\"\n        );\n        return false;\n      } else {\n        state.pendingManualTriggerFunction = manualTrigger.fun;\n        state.startIteration = index() + 1;\n\n        state.clientBatch = Math.ceil(jobClients() / manualTrigger.spread);\n        ++state.gatewayManualTriggerCount;\n        console.log(\"INFO: Set Pending Manual Trigger to \" + manualTrigger.fun);\n        // glob.incr(\"manualTriggerCount\",1);\n        metric.add(\"Gateway_pendingManualTrigger\");\n      }\n    } else {\n      // state.manualTriggerFunction = \"\";\n    }\n    if (\n      !!state.pendingManualTriggerFunction &&\n      Math.floor(client() / state.clientBatch) == (index() - state.startIteration)\n    ) {\n      state.manualTriggerFunction = state.pendingManualTriggerFunction;\n      state.pendingManualTriggerFunction = false;\n      console.log(\n        \"INFO: Set State Manual Trigger to \" + state.manualTriggerFunction\n      );\n      glob.incr(\"manualTriggerCount\", 1);\n      metric.add(\"Gateway_manualTrigger\");\n    } else {\n      state.manualTriggerFunction = \"\";\n    }\n  };\n\n  state._$helpers.handleHubCommand = async function (res) {\n    if (res && res.cmd === \"upgrade\") {\n      console.log(\"Received UPGRADE command\");\n      state.pubTopic = state._$gateway.thingName + \"/admin\"\n      state.upgrade = {\n        clientToken: res.clientToken,\n      };\n      let obj = {\n        fun: \"upgradeReport\",\n      };\n      // state._$queue.push(obj);\n      let p = await state.hubFunctions.upgradeReport();\n      protocol.publish(JSON.stringify(p), \"$aws/things/\"+state.pubTopic);\n      // state.PAYLOADS.push(p);\n    } else if (res && res.cmd === \"scan\") {\n      //TODO: refactor to account for topic change in queue\n      console.log(\"Received SCAN command\");\n      state.pubTopic = state._$gateway.thingName + \"/admin\"\n      state.scan = {\n        clientToken: res.clientToken,\n      };\n      let obj = {\n        fun: \"wifiScan\",\n      };\n      // state._$queue.push(obj);\n      let p = await state.hubFunctions.wifiScan();\n      protocol.publish(JSON.stringify(p), \"$aws/things/\" + state.pubTopic);\n      // state.PAYLOADS.push(p);\n    }\n/*\n291<=========>\ntopic : $aws/things/113385/hub\nmessage : {\"cmd\":\"Reboot\",\"clientToken\":\"113385-1642506644\"}\n<=========>\n */\n    else if (res && res.cmd === \"Reboot\") {\n      console.log(\"SEQINFO: Received Reboot command\");\n      // Ack message to be added here.\n      await state.hubFunctions.rebootHub()\n      \n    }\n\n    else if (res && res.cmd === \"tree\") {\n      console.log(\"Received TREE command\");\n\n      let bin = rest.get({\n        url:\n          \"https://rentlypt-hub-trees.s3.amazonaws.com/test-da964c401418df9328d374e9dfc6ecc2.tgz\",\n      });\n      if (!bin) {\n        state.payload_err = {\n          error: true,\n          iteration: state.iteration - 1,\n          msg: \"Failed to get firmware\",\n        };\n      } else {\n        state.tree = {\n          clientToken: res.clientToken,\n          ver: res.tree,\n        };\n        // state._$gateway = glob.get(\"gateway_\" + client());\n        state._$gateway.firmware = {\n          fwVer: res.tree,\n        };\n\n        // TODO:\n        // GET req to S3 bucket\n        // check if checksum matches\n        glob.set(\"gateway_\" + client(), state._$gateway);\n\n        // let obj = {\n        //   fun: \"sendFWver\",\n        // };\n        // state._$queue.push(obj); TODO\n        let p = await state.hubFunctions.sendFWver();\n        protocol.publish(JSON.stringify(p));\n        // state.PAYLOADS.push(p);\n      }\n    }\n  };\n\n  state._$helpers.verifyDevices = async function () {\n    metric.add(\"Gateway_verifyDevices\");\n    console.log(\"SEQINFO: Verifying Devices\");\n    state.unverifiedDeviceGUIDs.forEach(async (deviceGUID) => {\n      if (state._$gateway.deviceGUIDs.includes(deviceGUID)) {\n        console.log(\n          \"\" +\n            deviceGUID +\n            \"Already exists in gateway. Removing from unverified list\"\n        );\n        state.unverifiedDeviceGUIDs = state.unverifiedDeviceGUIDs.filter(\n          (unverifiedDeviceGUID) => unverifiedDeviceGUID !== deviceGUID\n        );\n      } else {\n        console.log(\n          \"Sending {}} to topic : \" +\n            \"$aws/things/\" +\n            deviceGUID +\n            \"/shadow/get\"\n        );\n\n        protocol.publish(\n          JSON.stringify({}),\n          \"$aws/things/\" + deviceGUID + \"/shadow/get\"\n        );\n        state.PAYLOADS.push(\n          \"Verification req sent to \" +\n            \"$aws/things/\" +\n            deviceGUID +\n            \"/shadow/get\"\n        );\n        metric.add(\"Gateway_getDevice\");\n        state.deviceVerificationTimerStart = Date.now();\n      }\n    });\n  };\n\n  state._$helpers.checkAPItoken = async function () {\n    state.token = await glob.get(\"APItoken\");\n    if (\n      !state.token ||\n      state.token?.token_exp <= Math.floor(Date.now() / 1000)\n    ) {\n      console.log(\"SEQINFO: Fetching new token\");\n      let obj = {\n        grant_type: \"password\",\n        username:\n          state.config?.API_TOKEN_CREDENTIALS?.username ||\n          \"latitudeadmin@rently.com\",\n        password: state.config?.API_TOKEN_CREDENTIALS?.password || \"iotify@123\",\n      };\n\n      let options = {\n        // url: \"https://d3vcdkc3ddc0sc.cloudfront.net/api/agents\",\n        // url: \"https://3ifxo.sse.codesandbox.io/rate\",\n        // json: obj,\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n      };\n\n      try {\n        let r = await rest.post(\n          \"https://d3vcdkc3ddc0sc.cloudfront.net/api/agents\",\n          obj,\n          options\n        );\n        console.log(\"RES\", r);\n        state.token = {\n          apiToken: r.access_token,\n          token_exp: Math.floor(Date.now() / 1000) + r.expires_in,\n        };\n        console.log(\"SEQINFO: Updated token: \", state.token);\n        await glob.set(\"APItoken\", state.token);\n      } catch (e) {\n        console.log(\"ERR: Failed to get API token\");\n      }\n    } else {\n      console.log(\"INFO: Glob contains valid Rently API Token : \", state.token);\n    }\n  };\n\n  if (!state._$gateway?.initialized)\n    state._$gateway.initialized = await state._$helpers.initGateway();\n\n  console.log(\"SEQINFO: Completed Helper State.\");\n  state.BootIterationsLeft = 1;\n\n  // Temporary\n  state._$gateway.nextNodeId = 3;\n\n  // state._$timestamp = new Date();\n  // protocol.publish(JSON.stringify(await state.hubFunctions.heartBeat()))\n\n  metric.add(\"Gateway_helperStateComplete\");\n  next(\"Booting\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Init": {
          "name": "Init",
          "isEnabled": true,
          "sender": "{\n  // Fetch necessary Glob Objects\n\n  state._$key = glob.get(\"gateway_\" + client() + \"_key\");\n  state._$cert = glob.get(\"gateway_\" + client() + \"_cert\");\n  state._$gateway = glob.get(\"gateway_\" + client());\n\n  console.log(\"Initial Gateway State : \", state._$gateway);\n\n  // Read configs\n  let config = glob.get(\"config\");\n\n  state._$iterationConfig = config?.iterationConfig?.gateway || []; // Contains interval for all functions\n  state._$REBOOT_SLEEP = config?.REBOOT_SLEEP || 5; // Number of iterations for sleeping during reboot\n  state.MAX_VERBOSE = config?.MAX_VERBOSE || true; // Toggle maximum verbosity of logs\n  state.CHECK_PARITY = config?.CHECK_PARITY || false; // Sets parity check for gateway devices\n  // state.SPREAD_MANUAL_TRIGGER = config?.SPREAD_MANUAL_TRIGGER || 10 // sets the number of iterations the manual trigger should be spread over.\n\n  console.log(\"INFO: REBOOT_SLEEP is set to : \", state._$REBOOT_SLEEP);\n  console.log(\"INFO: MAX_VERBOSE is set to : \", state.MAX_VERBOSE);\n  if (state.MAX_VERBOSE)\n    console.log(\"Iteration Config : \", state._$iterationConfig);\n\n  // Init state variables with default values\n  state._$unsentBuffer = [];\n  state.newDevices = [];\n  state.removeDevices = [];\n  state.unverifiedDeviceGUIDs = [];\n  state.PAYLOADS = [];\n  state.PREV_DELTAS = [];\n  state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n  state.gatewayManualTriggerCount = 0;\n  state.subscriptionTopics = [];\n  state._$unprocessedDeltas = [];\n  state._$unprocessedDeviceShadow = [];\n  state.pendingManualTriggerFunction = false;\n  state.subscriptionTopics.push(\n    \"$aws/things/\" + state._$gateway.thingName + \"/#\"\n  );\n\n  if (client() === 0) {\n    let manualTrigger = {\n      fun: \"\",\n      count: 0,\n      spread: 1,\n    };\n    await glob.set(\"manualTrigger\", manualTrigger);\n    await glob.set(\"manualTriggerCount\", 0);\n    await glob.set(\"Gateway_newDeltaDevice\", 0);\n    state.config = {\n      API_TOKEN_CREDENTIALS: config?.API_TOKEN_CREDENTIALS,\n    };\n  }\n\n  if (state._$gateway?.deviceGUIDs && state._$gateway.deviceGUIDs.length > 0) {\n    console.log(\"INFO: Resubscribing to device topics\");\n    state._$gateway.deviceGUIDs.forEach((device_thing_name) => {\n      state.subscriptionTopics.push(\"$aws/things/\" + device_thing_name + \"/#\");\n    });\n    protocol.resubscribe(state.subscriptionTopics);\n    console.log(\"Subscription Topics: \", state.subscriptionTopics)\n    metric.add(\"Gateway_resubscribe\");\n  }\n  next(\"Helpers\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 0
        },
        "Online": {
          "name": "Online",
          "isEnabled": true,
          "sender": "{\n  await metric.add(\"Gateway_iterationStart_\"+index());\n  try {\n    state._$timestamp = new Date();\n\n    await state._$helpers.checkManualTrigger();\n\n    if (client() === 0) {\n      await state._$helpers.checkAPItoken();\n    }\n\n    state._$iterationConfig.forEach(async function (obj) {\n      if (\n        Date.now() >= state._$nextExecution[obj.fun] ||\n        obj.fun === state?.manualTriggerFunction\n      ) {\n        console.log(\"TRIGGER: \", obj.fun);\n        try {\n          let tsStart = Date.now();\n          let payload = await state.hubFunctions[obj.fun]();\n          await protocol.publish(JSON.stringify(payload));\n          let tsEnd = Date.now();\n          metric.add(\"Gateway_\" + obj.fun + \"_duration\", tsEnd - tsStart);\n          state.PAYLOADS.push(payload);\n          state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n        } catch (e) {\n          console.log(\"ERR: \", e);\n        }\n\n        await metric.add(\"Gateway_\" + obj.fun);\n        await delay(100);\n      }\n    });\n\n  \n    if (state.unverifiedDeviceGUIDs.length > 0) {\n      await state._$helpers.verifyDevices();\n    }\n\n  \n    let mailboxReadStart = Date.now();\n    for (let i = 0; i < 25; ++i) {\n      let count = await mailbox.count(\"Gateway_\" + client() + \"_tx\");\n      if (count > 0) {\n        let mailbox_message = await mailbox.pop(\"Gateway_\" + client() + \"_tx\");\n        if (\n          typeof mailbox_message.topic === \"string\" &&\n          Object.keys(mailbox_message.payload).length > 0\n        ) {\n          console.log(\"INFO: Publishing message to : \" + mailbox_message.topic);\n          protocol.publish(mailbox_message.payload, mailbox_message.topic);\n          delay(1000)\n          metric.add(\"Gateway_deviceMessageSent\");\n        } else {\n          console.log(\"ERR: Invalid Mailbox message received\");\n        }\n      }\n    }\n    let mailboxReadEnd = Date.now();\n    metric.add(\n      \"Gateway_mailboxReadDuration\",\n      mailboxReadEnd - mailboxReadStart\n    );\n\n    if (state._$unprocessedDeltas.length > 0) {\n      console.log(\"Unprocessed Deltas present. Length: \" + state._$unprocessedDeltas.length);\n\n      let deltaProcessStart = Date.now()\n\n      for (let i = 0; i < Math.min(100, state._$unprocessedDeltas.length); ++i){\n        let delta = state._$unprocessedDeltas.shift()\n        try {\n          await state._$helpers.handleDelta(delta);\n        } catch (e) {\n          console.log(\"ERR: Handle Delta Failed \", e);\n        }\n      }\n      \n\n      metric.add('Gateway_deltaProcessTime', (Date.now() - deltaProcessStart))\n    }\n\n    if (state._$unprocessedDeviceShadow.length > 0) {\n      console.log(\"Unprocessed Shadows present. Length: \" + state._$unprocessedDeviceShadow.length);\n\n      let shadowProcessStart = Date.now()\n\n      for (let i = 0; i < Math.min(100, state._$unprocessedDeviceShadow.length ); ++i) {\n        let shadow = state._$unprocessedDeviceShadow.shift()\n        try {\n          await state._$helpers.newDevice(shadow);\n        } catch (e) {\n          console.log(\"ERR: Handle Shadow Failed \", e);\n        }\n      }\n\n      metric.add('Gateway_deviceShadowProcessTime', (Date.now() - shadowProcessStart))\n    }\n\n    if (state.CHECK_PARITY && (index() % 10 === 0 || index() === 2))\n      state._$helpers.checkDevicesParity();\n\n    glob.set(\"gateway_\" + client(), state._$gateway);\n\n    state.PAYLOADS = state.PAYLOADS.slice(0, 9);\n    state.PREV_DELTAS = state.PREV_DELTAS.slice(0, 9);\n\n    next(\"Online\");\n    state.ITERATION = \"ITERATION: \" + index();\n   \n  } catch (e) {\n    console.log(\"ERR: Error in Online State: \", e);\n  }\n  if (iteration() === jobRepeat() - 2) next(\"Finished\");\n}\n",
          "receiver": "{\n  metric.add('Gateway_onlineStateRH')\n  let tsStart = Date.now();\n  console.log(\"RH : Iteration: \" + index() + \" | Topic: \", response.topic);\n  let topic = response.topic;\n  if (!topic || topic.split(\"/\").length < 3) return\n  if (!response?.message) return\n  \n  let res = {};\n\n  try {\n\n    res = await JSON.parse(response?.message.toString());\n  } catch (e) {\n    console.log(\"ERR: Failed to parse response \", e, response.message);\n  }\n  // state._$gateway = await glob.get(\"gateway_\" + client());\n\n  let device_thing_name = topic.split(\"/\")[2] || \"\";\n  console.log(\"Received Message for :\", device_thing_name);\n\n  if (\n    topic ===\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/delta\"\n  ) {\n    metric.add('Gateway_deltaRH')\n    // try {\n    //   await state._$helpers.handleDelta(res);\n    // } catch (e) {\n    //   console.log(\"ERR: Handle Delta Failed \", e);\n    // }\n    if (!!res.state) {\n      state._$unprocessedDeltas.push(res)\n      console.log(\"Received Delta pushed to processing queue. Queue Length : \" + state._$unprocessedDeltas.length)\n    } else {\n      console.log(\"Ignoring Delta: contains no state\")\n      metric.add('Gateway_deltaReceivedWithoutState')\n\n    }\n    \n  }\n  // else if (\n  //   topic ===\n  //   \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/documents\"\n  // ) {\n  //   metric.add('shadow_document')\n  //   if (Array.isArray(res.current?.state?.desired?.settings?.devices) && res.current?.state?.desired?.settings?.devices.length > 0) metric.add('shadow_document_devices')\n  //   console.log(\"Received /update/document contains devices : \", res.current?.state?.desired?.settings?.devices)\n  //   try {\n  //     await state._$helpers.checkDevices(\n  //       res.current?.state?.desired?.settings?.devices\n  //     );\n  //   } catch (e) {\n  //     console.log(\"ERR: Handle Document Failed \", e);\n  //   }\n  // }\n  else if (topic === \"$aws/things/\" + state._$gateway.thingName + \"/hub\") {\n    console.log(\"Received hub command\");\n    metric.add('Gateway_hubCommandRX');\n    state._$helpers.handleHubCommand(res);\n  } else if (\n    topic ===\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/rejected\"\n  ) {\n    console.log(\"Received Reject message\", JSON.stringify(res));\n    metric.add(\"Gateway_payloadRejected\");\n  } else if (\n    topic ===\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/get/accepted\"\n  ) {\n    console.log(\"Received Gateway Get Response\");\n    metric.add(\"Gateway_GetResponse\");\n    metric.add('Gateway_GetResponseTime', (Date.now() - state?.getGatewayTimerStart))\n    if (\n      Array.isArray(res?.state?.desired?.settings?.devices) &&\n      res?.state?.desired?.settings?.devices.length > 0\n    ) {\n      await state._$helpers.checkDevices(\n        res?.state?.desired?.settings?.devices\n      );\n    } else {\n      console.log(\"INFO: Get Response contains no devices array\");\n      if (state.MAX_VERBOSE) console.log(JSON.stringify(res));\n    }\n  }  else if (\n    state.unverifiedDeviceGUIDs.includes(device_thing_name) &&\n    topic === \"$aws/things/\" + device_thing_name + \"/shadow/get/accepted\"\n  ) {\n    metric.add(\"Gateway_getDeviceResponse\");\n    metric.add(\"Gateway_getDeviceResponseTime\", (Date.now() - state?.deviceVerificationTimerStart));\n    state._$unprocessedDeviceShadow.push(res)\n    console.log(\"SEQINFO: Pusing shadow to unprocessed queue. Queue Length: \" + state._$unprocessedDeviceShadow.length);\n\n\n  } else if (state._$gateway.deviceGUIDs.includes(device_thing_name)) {\n    console.log(\"SEQINFO: Pushing to mailbox \", \"\" + device_thing_name + \"_rx\");\n    metric.add(\"Gateway_deviceMessagesReceived\");\n    mailbox.post(\"\" + device_thing_name + \"_rx\", { topic, res });\n    let count = await mailbox.count(\"\" + device_thing_name + \"_rx\");\n    console.log(\"Mailbox count of \" + device_thing_name + \"_rx : \" + count);\n  }\n  let tsEnd = Date.now();\n  metric.add(\"RH_duration\", tsEnd - tsStart);\n}\n",
          "icon": "",
          "index": 4
        },
        "Finished": {
          "name": "Finished",
          "isEnabled": true,
          "sender": "\n{\n  let devices = state._$gateway.deviceGUIDs\n\n  glob.incr('shadowDevice', devices.length)\n  metric.add('Stripped_totalDevices', devices.length)\n  console.log(\"state._$gateway.deviceGUIDs.length=\" + devices.length)\n  console.log(state._$gateway.deviceGUIDs)\n  \n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 6
        },
        "Offline": {
          "index": 5,
          "name": "Offline",
          "isEnabled": false,
          "sender": "\n{\n  metric.add('Gateway_offlineState')\n  state._$timestamp = new Date();\n  iterationConfig.forEach(async function (obj) {\n    if (Date.now() >= state._$nextExecution[obj.fun]) {\n      state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n\n      console.log(\"TRIGGER: \", obj.fun);\n      payload = await state.hubFunctions[obj.fun]();\n      state._$unsentBuffer.push(payload);\n    }\n  });\n  console.log('SEQINFO: In Offline State')\n  console.log('DBGINFO: Unsent Buffer Length : ' + state._$unsentBuffer.length);\n\n  if(state.MAX_VERBOSE) console.log('VERBOSE: ', JSON.stringify(state._$unsentBuffer))\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Booting": {
          "index": 2,
          "name": "Booting",
          "isEnabled": true,
          "sender": "{\n  state._$timestamp = new Date();\n  await glob.set(\"gateway_\" + client() + \"_active\", false);\n\n  //if (--state.BootIterationsLeft <= 0) {   // TBD check with Robin about the logic here\n  if (--state.BootIterationsLeft <= 0) {\n    console.log(\"SEQINFO: Done Booting\");\n\n    try {\n      metric.add('Gateway_heartBeat')\n      await protocol.publish(JSON.stringify(await state.hubFunctions.heartBeat()));\n      await delay(2000)\n      \n      await protocol.publish(JSON.stringify(await state.hubFunctions.sendFWver()));\n      await delay(2000)\n\n      // await protocol.publish(JSON.stringify(await state.hubFunctions.sendICCID()));\n      // await delay(2000)\n\n      // await protocol.publish(JSON.stringify(await state.hubFunctions.sendBoardType()));\n      // await delay(2000)\n\n      await protocol.publish(JSON.stringify(await state.hubFunctions.sendConnectionType()));\n      await delay(2000)\n\n      // await protocol.publish(JSON.stringify(await state.hubFunctions.sendBLEmode()));\n    } catch (e) {\n      console.log(e);\n    }\n    \n    state._$nextExecution.switchCentral = Date.now() + 180000;\n\n    glob.set(\"gateway_\" + client() + \"_active\", true);\n    metric.add('Gateway_bootingStateComplete', 1)\n    next(\"Online\");\n  }\n  metric.add('Gateway_bootingState', 1)\n  console.log(\"SEQINFO: In Booting State\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Clearing_Unsent": {
          "index": 3,
          "name": "Clearing_Unsent",
          "isEnabled": false,
          "sender": "\n{\n  \n\n  while (state._$unsentBuffer.length > 0) {\n    await delay(100)\n    await protocol.publish(JSON.stringify(state._$unsentBuffer.shift()));\n  }\n\n  console.log('SEQINFO: Completed Clearing Unsent State.')\n  next('Online');\n  \n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        }
      },
      "setup": "",
      "teardown": ""
    }
  }
}